<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D市街地ビュー - 夕方の西日</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; }
    canvas { display: block; }
    .info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      border-radius: 5px;
      pointer-events: none;
    }
    .controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      border-radius: 5px;
    }
    button {
      margin: 5px;
      padding: 5px 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="info">
    <h3>3D市街地ビュー - 夕方の西日</h3>
    <p>500m×500mの市街地シミュレーション</p>
    <p>時間: 夕方（西からの日差し）</p>
  </div>
  <div class="controls">
    <button id="toggleDrive">ドライブモード: OFF</button>
    <button id="toggleView">視点切替</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // シーンの設定
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // 空色
    
    // カメラの設定
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(100, 50, 100);
    camera.lookAt(0, 0, 0);
    
    // レンダラーの設定
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    
    // 光源の設定（夕方の西日）
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // 環境光
    scene.add(ambientLight);
    
    const sunlight = new THREE.DirectionalLight(0xFFA500, 1); // オレンジっぽい夕日
    sunlight.position.set(-50, 30, 0); // 西から光が差し込む
    sunlight.castShadow = true;
    sunlight.shadow.camera.left = -250;
    sunlight.shadow.camera.right = 250;
    sunlight.shadow.camera.top = 250;
    sunlight.shadow.camera.bottom = -250;
    sunlight.shadow.camera.far = 500;
    sunlight.shadow.mapSize.width = 2048;
    sunlight.shadow.mapSize.height = 2048;
    scene.add(sunlight);

    // 霞効果（夕日の雰囲気）
    scene.fog = new THREE.FogExp2(0xFFA07A, 0.002);
    
    // 地面（500m x 500m）
    const groundGeometry = new THREE.PlaneGeometry(500, 500);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 }); // アスファルト色
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // 建物タイプの定義
    const buildingTypes = [
      {
        name: "高層ビル",
        geometry: (x, z) => new THREE.BoxGeometry(15, 40 + Math.random() * 20, 15),
        material: () => new THREE.MeshLambertMaterial({ color: 0x99CCFF }) // ガラス張りの高層ビル
      },
      {
        name: "中層オフィス",
        geometry: (x, z) => new THREE.BoxGeometry(20, 20 + Math.random() * 10, 20),
        material: () => new THREE.MeshLambertMaterial({ color: 0xDDDDDD }) // グレー
      },
      {
        name: "低層商業ビル",
        geometry: (x, z) => new THREE.BoxGeometry(25, 10 + Math.random() * 5, 20),
        material: () => new THREE.MeshLambertMaterial({ color: 0xFFCCCC }) // 薄ピンク
      },
      {
        name: "マンション",
        geometry: (x, z) => new THREE.BoxGeometry(30, 15 + Math.random() * 10, 20),
        material: () => new THREE.MeshLambertMaterial({ color: 0xCCDDCC }) // 薄緑
      }
    ];
    
    // 道路の配置（十字路）
    function createRoads() {
      // メイン道路（東西）
      const mainRoadEW = new THREE.Mesh(
        new THREE.PlaneGeometry(500, 20),
        new THREE.MeshLambertMaterial({ color: 0x666666 })
      );
      mainRoadEW.rotation.x = -Math.PI / 2;
      mainRoadEW.position.y = 0.1;
      mainRoadEW.receiveShadow = true;
      scene.add(mainRoadEW);
      
      // メイン道路（南北）
      const mainRoadNS = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 500),
        new THREE.MeshLambertMaterial({ color: 0x666666 })
      );
      mainRoadNS.rotation.x = -Math.PI / 2;
      mainRoadNS.position.y = 0.1;
      mainRoadNS.receiveShadow = true;
      scene.add(mainRoadNS);
      
      // サブ道路（東西方向に3本）
      for (let i = -1; i <= 1; i++) {
        if (i === 0) continue; // メイン道路と重複する位置はスキップ
        
        const subRoadEW = new THREE.Mesh(
          new THREE.PlaneGeometry(500, 15),
          new THREE.MeshLambertMaterial({ color: 0x666666 })
        );
        subRoadEW.rotation.x = -Math.PI / 2;
        subRoadEW.position.y = 0.1;
        subRoadEW.position.z = i * 100;
        subRoadEW.receiveShadow = true;
        scene.add(subRoadEW);
      }
      
      // サブ道路（南北方向に3本）
      for (let i = -1; i <= 1; i++) {
        if (i === 0) continue; // メイン道路と重複する位置はスキップ
        
        const subRoadNS = new THREE.Mesh(
          new THREE.PlaneGeometry(15, 500),
          new THREE.MeshLambertMaterial({ color: 0x666666 })
        );
        subRoadNS.rotation.x = -Math.PI / 2;
        subRoadNS.position.y = 0.1;
        subRoadNS.position.x = i * 100;
        subRoadNS.receiveShadow = true;
        scene.add(subRoadNS);
      }
      
      // 歩道（メイン道路沿い）
      const sidewalkMaterial = new THREE.MeshLambertMaterial({ color: 0xCCCCCC });
      
      // 東西メイン道路の歩道
      for (let side = -1; side <= 1; side += 2) {
        const sidewalkEW = new THREE.Mesh(
          new THREE.PlaneGeometry(500, 5),
          sidewalkMaterial
        );
        sidewalkEW.rotation.x = -Math.PI / 2;
        sidewalkEW.position.y = 0.15;
        sidewalkEW.position.z = side * 12.5;
        sidewalkEW.receiveShadow = true;
        scene.add(sidewalkEW);
      }
      
      // 南北メイン道路の歩道
      for (let side = -1; side <= 1; side += 2) {
        const sidewalkNS = new THREE.Mesh(
          new THREE.PlaneGeometry(5, 500),
          sidewalkMaterial
        );
        sidewalkNS.rotation.x = -Math.PI / 2;
        sidewalkNS.position.y = 0.15;
        sidewalkNS.position.x = side * 12.5;
        sidewalkNS.receiveShadow = true;
        scene.add(sidewalkNS);
      }
      
      // 横断歩道の追加
      createCrosswalk(0, 20, "EW"); // メイン交差点の南側
      createCrosswalk(0, -20, "EW"); // メイン交差点の北側
      createCrosswalk(20, 0, "NS"); // メイン交差点の東側
      createCrosswalk(-20, 0, "NS"); // メイン交差点の西側
      
      // サブ交差点にも横断歩道を追加
      for (let x = -100; x <= 100; x += 100) {
        if (x === 0) continue;
        for (let z = -100; z <= 100; z += 100) {
          if (z === 0) continue;
          createCrosswalk(x, z + 10, "EW");
          createCrosswalk(x, z - 10, "EW");
          createCrosswalk(x + 10, z, "NS");
          createCrosswalk(x - 10, z, "NS");
        }
      }
    }
    
    // 横断歩道を作成する関数
    function createCrosswalk(x, z, direction) {
      const width = direction === "EW" ? 15 : 4;
      const height = direction === "EW" ? 4 : 15;
      
      for (let i = 0; i < 5; i++) {
        const offset = (i - 2) * 2;
        const stripeX = direction === "EW" ? x : x + offset;
        const stripeZ = direction === "EW" ? z + offset : z;
        
        const stripe = new THREE.Mesh(
          new THREE.PlaneGeometry(width, height),
          new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
        );
        stripe.rotation.x = -Math.PI / 2;
        stripe.position.set(stripeX, 0.16, stripeZ);
        stripe.receiveShadow = true;
        scene.add(stripe);
      }
    }
    
    // 信号機を作成する関数
    function createTrafficLight(x, z) {
      const pole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.3, 7, 8),
        new THREE.MeshLambertMaterial({ color: 0x333333 })
      );
      pole.position.set(x, 3.5, z);
      pole.castShadow = true;
      scene.add(pole);
      
      const head = new THREE.Mesh(
        new THREE.BoxGeometry(1, 3, 1),
        new THREE.MeshLambertMaterial({ color: 0x222222 })
      );
      head.position.set(x, 7, z);
      head.castShadow = true;
      scene.add(head);
      
      // 信号のライト
      const colors = [0xFF0000, 0xFFFF00, 0x00FF00];
      for (let i = 0; i < 3; i++) {
        const light = new THREE.Mesh(
          new THREE.CircleGeometry(0.3, 16),
          new THREE.MeshBasicMaterial({ color: colors[i] })
        );
        light.position.set(x, 6 + i, z + 0.51);
        light.rotation.y = Math.PI;
        scene.add(light);
      }
    }
    
    // 街灯を作成する関数
    function createStreetLight(x, z) {
      const pole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.3, 8, 8),
        new THREE.MeshLambertMaterial({ color: 0x333333 })
      );
      pole.position.set(x, 4, z);
      pole.castShadow = true;
      scene.add(pole);
      
      const arm = new THREE.Mesh(
        new THREE.BoxGeometry(3, 0.2, 0.2),
        new THREE.MeshLambertMaterial({ color: 0x333333 })
      );
      arm.position.set(x + 1.5, 8, z);
      arm.castShadow = true;
      scene.add(arm);
      
      const lamp = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.8, 1, 8),
        new THREE.MeshBasicMaterial({ color: 0xFFFF99, transparent: true, opacity: 0.8 })
      );
      lamp.rotation.x = Math.PI / 2;
      lamp.position.set(x + 3, 7.8, z);
      scene.add(lamp);
      
      // 街灯の光源
      const light = new THREE.PointLight(0xFFFFCC, 1, 30);
      light.position.set(x + 3, 7.5, z);
      light.castShadow = true;
      light.shadow.mapSize.width = 512;
      light.shadow.mapSize.height = 512;
      scene.add(light);
    }
    
    // 街路樹を作成する関数
    function createTree(x, z) {
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.7, 4, 8),
        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
      );
      trunk.position.set(x, 2, z);
      trunk.castShadow = true;
      scene.add(trunk);
      
      const leaves = new THREE.Mesh(
        new THREE.SphereGeometry(3, 16, 16),
        new THREE.MeshLambertMaterial({ color: 0x228B22 })
      );
      leaves.position.set(x, 6, z);
      leaves.castShadow = true;
      scene.add(leaves);
    }
    
    // 建物を配置する関数
    function placeBuildings() {
      const gridSize = 50; // グリッドの大きさ
      const buildingSpots = [];
      
      // 道路を避けるための条件
      function isNearRoad(x, z) {
        // メインロード付近
        if (Math.abs(x) < 20 || Math.abs(z) < 20) return true;
        
        // サブロード付近
        for (let i = -100; i <= 100; i += 100) {
          if (Math.abs(x - i) < 15 || Math.abs(z - i) < 15) return true;
        }
        
        return false;
      }
      
      // 建物の配置場所を決定
      for (let x = -225; x <= 225; x += gridSize) {
        for (let z = -225; z <= 225; z += gridSize) {
          // 道路や交差点を避ける
          if (!isNearRoad(x, z)) {
            // ランダムなオフセットを追加
            const offsetX = (Math.random() - 0.5) * 10;
            const offsetZ = (Math.random() - 0.5) * 10;
            buildingSpots.push({
              x: x + offsetX,
              z: z + offsetZ,
              type: buildingTypes[Math.floor(Math.random() * buildingTypes.length)]
            });
          }
        }
      }
      
      // 建物の生成と配置
      buildingSpots.forEach(spot => {
        const { x, z, type } = spot;
        const geometry = type.geometry(x, z);
        const material = type.material();
        const building = new THREE.Mesh(geometry, material);
        
        // 建物の位置を設定（高さの半分を上に）
        building.position.set(x, geometry.parameters.height / 2, z);
        building.castShadow = true;
        building.receiveShadow = true;
        scene.add(building);
      });
    }
    
    // 街灯と信号機の配置
    function placeStreetFurniture() {
      // メイン交差点に信号機を配置
      createTrafficLight(12, 12);
      createTrafficLight(-12, 12);
      createTrafficLight(-12, -12);
      createTrafficLight(12, -12);
      
      // サブ交差点にも信号機を配置
      for (let x = -100; x <= 100; x += 100) {
        if (x === 0) continue;
        for (let z = -100; z <= 100; z += 100) {
          if (z === 0) continue;
          createTrafficLight(x + 7, z + 7);
          createTrafficLight(x - 7, z + 7);
          createTrafficLight(x - 7, z - 7);
          createTrafficLight(x + 7, z - 7);
        }
      }
      
      // 街灯の配置（メイン道路）
      for (let pos = -240; pos <= 240; pos += 40) {
        // 東西道路
        createStreetLight(pos, 15);
        createStreetLight(pos, -15);
        
        // 南北道路
        createStreetLight(15, pos);
        createStreetLight(-15, pos);
      }
      
      // 街路樹の配置
      for (let pos = -220; pos <= 220; pos += 20) {
        // 交差点を避ける
        if (Math.abs(pos) < 30 || (Math.abs(pos - 100) < 30) || (Math.abs(pos + 100) < 30)) continue;
        
        // 東西メイン道路
        createTree(pos, 17);
        createTree(pos, -17);
        
        // 南北メイン道路
        createTree(17, pos);
        createTree(-17, pos);
      }
    }
    
    // 車を作成する関数
    function createCar(color) {
      const car = new THREE.Group();
      
      // 車体
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(5, 1.5, 2.5),
        new THREE.MeshLambertMaterial({ color: color })
      );
      body.position.y = 1;
      body.castShadow = true;
      car.add(body);
      
      // 上部
      const top = new THREE.Mesh(
        new THREE.BoxGeometry(3, 1, 2),
        new THREE.MeshLambertMaterial({ color: color })
      );
      top.position.set(-0.5, 2.25, 0);
      top.castShadow = true;
      car.add(top);
      
      // ヘッドライト
      for (let i = -1; i <= 1; i += 2) {
        const headlight = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 0.5),
          new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
        );
        headlight.position.set(2.55, 1, i * 0.8);
        car.add(headlight);
        
        // テールライト
        const taillight = new THREE.Mesh(
          new THREE.BoxGeometry(0.1, 0.5, 0.5),
          new THREE.MeshBasicMaterial({ color: 0xFF0000 })
        );
        taillight.position.set(-2.55, 1, i * 0.8);
        car.add(taillight);
      }
      
      // タイヤ
      const wheelPositions = [
        { x: 1.5, y: 0.4, z: 1.5 },
        { x: 1.5, y: 0.4, z: -1.5 },
        { x: -1.5, y: 0.4, z: 1.5 },
        { x: -1.5, y: 0.4, z: -1.5 }
      ];
      
      wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5, 0.5, 0.5, 16),
          new THREE.MeshLambertMaterial({ color: 0x111111 })
        );
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(pos.x, pos.y, pos.z);
        car.add(wheel);
      });
      
      return car;
    }
    
    // トラフィックシステム
    const traffic = [];
    function createTraffic() {
      const carColors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFFFFFF, 0x00FFFF, 0x000000, 0x999999];
      
      // 東西方向の道路に車を配置
      for (let z = -100; z <= 100; z += 100) {
        for (let x = -200; x < 200; x += 30) {
          if (Math.random() < 0.7) { // 70%の確率で車を配置
            const randomColor = carColors[Math.floor(Math.random() * carColors.length)];
            const car = createCar(randomColor);
            
            // 東向き車線
            if (Math.random() < 0.5) {
              car.position.set(x, 0, z + 3);
              car.rotation.y = 0;
            } 
            // 西向き車線
            else {
              car.position.set(x, 0, z - 3);
              car.rotation.y = Math.PI;
            }
            
            scene.add(car);
            
            // 速度をランダムに設定
            const speed = 0.1 + Math.random() * 0.3;
            traffic.push({
              object: car,
              speed: speed,
              direction: car.rotation.y === 0 ? "east" : "west"
            });
          }
        }
      }
      
      // 南北方向の道路に車を配置
      for (let x = -100; x <= 100; x += 100) {
        for (let z = -200; z < 200; z += 30) {
          if (Math.random() < 0.7) { // 70%の確率で車を配置
            const randomColor = carColors[Math.floor(Math.random() * carColors.length)];
            const car = createCar(randomColor);
            
            // 南向き車線
            if (Math.random() < 0.5) {
              car.position.set(x + 3, 0, z);
              car.rotation.y = Math.PI / 2;
            } 
            // 北向き車線
            else {
              car.position.set(x - 3, 0, z);
              car.rotation.y = -Math.PI / 2;
            }
            
            scene.add(car);
            
            // 速度をランダムに設定
            const speed = 0.1 + Math.random() * 0.3;
            traffic.push({
              object: car,
              speed: speed,
              direction: car.rotation.y === Math.PI / 2 ? "south" : "north"
            });
          }
        }
      }
      
      // プレイヤー用の車（赤色、最初はオフ）
      playerCar = createCar(0xFF0000);
      playerCar.position.set(0, 0, 7);
      playerCar.visible = false;
      scene.add(playerCar);
    }
    
    // 都市の初期化
    function initCity() {
      createRoads();
      placeBuildings();
      placeStreetFurniture();
      createTraffic();
    }
    
    // 都市の初期化を実行
    initCity();
    
    // トラフィックの更新
    function updateTraffic() {
      traffic.forEach(car => {
        const { object, speed, direction } = car;
        
        switch (direction) {
          case "east":
            object.position.x += speed;
            // 境界チェック
            if (object.position.x > 250) {
              object.position.x = -250;
            }
            break;
          case "west":
            object.position.x -= speed;
            if (object.position.x < -250) {
              object.position.x = 250;
            }
            break;
          case "north":
            object.position.z -= speed;
            if (object.position.z < -250) {
              object.position.z = 250;
            }
            break;
          case "south":
            object.position.z += speed;
            if (object.position.z > 250) {
              object.position.z = -250;
            }
            break;
        }
      });
    }
    
    // ウィンドウリサイズ対応
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // ドライブモード用の変数
    let isDriving = false;
    let playerCar;
    let drivingSpeed = 0;
    let drivingRotation = 0;
    let cameraMode = "thirdPerson"; // "firstPerson" または "thirdPerson"
    
    // キー操作
    const keys = {};
    window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
    });
    
    window.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });
    
    // ドライブモード切替ボタン
    document.getElementById('toggleDrive').addEventListener('click', () => {
      isDriving = !isDriving;
      document.getElementById('toggleDrive').textContent = `ドライブモード: ${isDriving ? 'ON' : 'OFF'}`;
      
      if (isDriving) {
        playerCar.visible = true;
        // ドライブモード開始時のカメラ位置
        updateDriveCamera();
      } else {
        playerCar.visible = false;
        // 通常モードのカメラ位置に戻す
        camera.position.set(100, 50, 100);
        camera.lookAt(0, 0, 0);
      }
    });
    
    // 視点切替ボタン
    document.getElementById('toggleView').addEventListener('click', () => {
      if (isDriving) {
        cameraMode = cameraMode === "thirdPerson" ? "firstPerson" : "thirdPerson";
        updateDriveCamera();
      }
    });
    
    // ドライブモードのカメラ更新
    function updateDriveCamera() {
      if (cameraMode === "firstPerson") {
        // 一人称視点（車内から）
        camera.position.x = playerCar.position.x - 2 * Math.sin(playerCar.rotation.y);
        camera.position.y = playerCar.position.y + 2;
        camera.position.z = playerCar.position.z - 2 * Math.cos(playerCar.rotation.y);
        camera.lookAt(
          playerCar.position.x + 10 * Math.sin(playerCar.rotation.y),
          playerCar.position.y + 1,
          playerCar.position.z + 10 * Math.cos(playerCar.rotation.y)
        );
      } else {
        // 三人称視点（車の後ろから）
        camera.position.x = playerCar.position.x - 10 * Math.sin(playerCar.rotation.y);
        camera.position.y = playerCar.position.y + 5;
        camera.position.z = playerCar.position.z - 10 * Math.cos(playerCar.rotation.y);
        camera.lookAt(playerCar.position);
      }
    }
    
    // ドライブモードの操作更新
    function updateDriving() {
      if (!isDriving) return;
      
      // 加速と
