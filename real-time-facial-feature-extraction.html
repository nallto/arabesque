<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>シンプルなカメラエフェクトアプリ</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: sans-serif;
            background-color: #f0f0f0;
        }
        
        h1 {
            margin-bottom: 20px;
            color: #333;
        }
        
        .container {
            position: relative;
            margin: 0 auto;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            overflow: hidden;
        }
        
        video, canvas {
            border-radius: 8px;
        }
        
        canvas {
            display: block;
        }
        
        #status {
            margin-top: 20px;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border-radius: 4px;
            text-align: center;
            width: 100%;
            max-width: 640px;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            width: 100%;
            max-width: 640px;
        }
        
        .button {
            padding: 10px 20px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .button:hover {
            background-color: #0b7dda;
        }
        
        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .button.active {
            background-color: #4CAF50;
        }
    </style>
</head>
<body>
    <h1>カメラエフェクトアプリ</h1>
    
    <div class="container">
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>
    
    <div id="status">カメラへのアクセスを準備中...</div>
    
    <div class="controls">
        <button id="startButton" class="button">開始</button>
        <button id="effectNone" class="button active">通常</button>
        <button id="effectGreyscale" class="button">グレースケール</button>
        <button id="effectEdge" class="button">輪郭検出</button>
        <button id="effectGrid" class="button">グリッド線</button>
        <button id="effectFace" class="button">顔検出シミュレーション</button>
        <button id="captureButton" class="button">写真を撮る</button>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('status');
        const startButton = document.getElementById('startButton');
        const captureButton = document.getElementById('captureButton');
        const effectButtons = {
            none: document.getElementById('effectNone'),
            greyscale: document.getElementById('effectGreyscale'),
            edge: document.getElementById('effectEdge'),
            grid: document.getElementById('effectGrid'),
            face: document.getElementById('effectFace')
        };
        
        let currentEffect = 'none';
        let isRunning = false;
        let video = document.createElement('video');
        video.autoplay = true;
        video.muted = true;
        
        // カメラのセットアップ
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        resolve(video);
                    };
                });
            } catch (error) {
                statusText.textContent = 'カメラアクセスエラー: ' + error.message;
                statusText.style.backgroundColor = '#f44336';
                throw error;
            }
        }
        
        // エフェクト処理
        function applyEffect(imageData) {
            const data = imageData.data;
            
            switch (currentEffect) {
                case 'greyscale':
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = avg;     // R
                        data[i + 1] = avg; // G
                        data[i + 2] = avg; // B
                    }
                    break;
                    
                case 'edge':
                    // シンプルな輪郭検出（差分を強調）
                    const width = imageData.width;
                    const tempData = new Uint8ClampedArray(data);
                    
                    for (let y = 1; y < imageData.height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const idx = (y * width + x) * 4;
                            
                            // 周囲のピクセルとの差を計算
                            const diffH = Math.abs(tempData[idx] - tempData[idx + 4]) +
                                         Math.abs(tempData[idx + 1] - tempData[idx + 5]) +
                                         Math.abs(tempData[idx + 2] - tempData[idx + 6]);
                                         
                            const diffV = Math.abs(tempData[idx] - tempData[idx + width * 4]) +
                                         Math.abs(tempData[idx + 1] - tempData[idx + width * 4 + 1]) +
                                         Math.abs(tempData[idx + 2] - tempData[idx + width * 4 + 2]);
                            
                            // 差が大きい場合は輪郭として白、それ以外は黒
                            const edge = (diffH + diffV) > 100 ? 255 : 0;
                            
                            data[idx] = edge;     // R
                            data[idx + 1] = edge; // G
                            data[idx + 2] = edge; // B
                        }
                    }
                    break;
                    
                case 'face':
                    // 顔検出のシミュレーション（実際の顔検出ではなく、単純な円と特徴を描画）
                    break;
                    
                case 'grid':
                    // グリッドは画像データを変更せず、後から描画します
                    break;
                    
                default:
                    // 通常表示（エフェクトなし）
                    break;
            }
            
            return imageData;
        }
        
        // 描画ループ
        function renderFrame() {
            if (!isRunning) return;
            
            // カメラ映像をキャンバスに描画
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // 画像データを取得
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // エフェクトを適用
            const processedData = applyEffect(imageData);
            
            // 処理した画像データを描画
            ctx.putImageData(processedData, 0, 0);
            
            // 追加の描画（エフェクトごと）
            if (currentEffect === 'grid') {
                drawGrid();
            } else if (currentEffect === 'face') {
                drawFaceSimulation();
            }
            
            // 次のフレームをリクエスト
            requestAnimationFrame(renderFrame);
        }
        
        // グリッド線を描画
        function drawGrid() {
            const gridSize = 20;
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            
            // 縦線
            for (let x = gridSize; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // 横線
            for (let y = gridSize; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }
        
        // 顔検出シミュレーション
        function drawFaceSimulation() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2 - 50;
            const faceRadius = 100;
            
            // 顔の円
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, faceRadius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // 左目
            ctx.beginPath();
            ctx.arc(centerX - 30, centerY - 20, 10, 0, 2 * Math.PI);
            ctx.stroke();
            
            // 右目
            ctx.beginPath();
            ctx.arc(centerX + 30, centerY - 20, 10, 0, 2 * Math.PI);
            ctx.stroke();
            
            // 鼻
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - 10);
            ctx.lineTo(centerX - 10, centerY + 20);
            ctx.lineTo(centerX + 10, centerY + 20);
            ctx.closePath();
            ctx.stroke();
            
            // 口
            ctx.beginPath();
            ctx.arc(centerX, centerY + 30, 30, 0.2 * Math.PI, 0.8 * Math.PI);
            ctx.stroke();
            
            // 特徴点をシミュレート
            ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
            
            // 顔の輪郭の点
            for (let angle = 0; angle < 2 * Math.PI; angle += 0.2) {
                const x = centerX + faceRadius * Math.cos(angle);
                const y = centerY + faceRadius * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // 目の周りの点
            for (let angle = 0; angle < 2 * Math.PI; angle += 0.4) {
                // 左目
                let x = centerX - 30 + 10 * Math.cos(angle);
                let y = centerY - 20 + 10 * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
                
                // 右目
                x = centerX + 30 + 10 * Math.cos(angle);
                y = centerY - 20 + 10 * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // 鼻の点
            for (let i = 0; i < 5; i++) {
                const t = i / 4;
                const x = centerX - 10 + 20 * t;
                const y = centerY + 20;
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // 口の点
            for (let angle = 0.2 * Math.PI; angle <= 0.8 * Math.PI; angle += 0.1) {
                const x = centerX + 30 * Math.cos(angle);
                const y = centerY + 30 + 30 * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        // 写真撮影
        function capturePhoto() {
            const dataURL = canvas.toDataURL('image/png');
            
            // 新しいウィンドウで開く
            const
